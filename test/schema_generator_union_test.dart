import 'package:schema2model/src/generator.dart';
import 'package:test/test.dart';

void main() {
  group('oneOf/anyOf unions', () {
    test('builds IR for discriminated unions', () {
      const unionSchema = <String, dynamic>{
        'title': 'Step',
        'description': 'A workflow step.',
        'oneOf': [
          {
            'title': 'Run',
            'type': 'object',
            'required': ['type', 'run'],
            'properties': {
              'type': {'const': 'run'},
              'run': {'type': 'string'},
            },
          },
          {
            'title': 'Uses',
            'type': 'object',
            'required': ['type', 'uses'],
            'properties': {
              'type': {'const': 'uses'},
              'uses': {'type': 'string'},
            },
          },
        ],
        'discriminator': {
          'propertyName': 'type',
          'mapping': {'run': '#/oneOf/0', 'uses': '#/oneOf/1'},
        },
      };

      final generator = SchemaGenerator(
        options: const SchemaGeneratorOptions(),
      );
      final ir = generator.buildIr(unionSchema);

      expect(ir.unions, hasLength(1));
      final union = ir.unions.single;
      expect(union.name, 'Step');
      expect(ir.rootClass.name, 'Step');
      expect(union.isDiscriminated, isTrue);
      expect(
        union.variants.map((variant) => variant.classSpec.name).toList(),
        containsAll(<String>['Run', 'Uses']),
      );
      final runVariant = union.variants.firstWhere(
        (variant) => variant.discriminatorValue == 'run',
      );
      expect(runVariant.constProperties['type'], 'run');
    });

    test('emits sealed union classes with discriminator handling', () {
      const unionSchema = <String, dynamic>{
        'title': 'Step',
        'oneOf': [
          {
            'title': 'Run',
            'type': 'object',
            'required': ['type', 'run'],
            'properties': {
              'type': {'const': 'run'},
              'run': {'type': 'string'},
            },
          },
          {
            'title': 'Uses',
            'type': 'object',
            'required': ['type', 'uses'],
            'properties': {
              'type': {'const': 'uses'},
              'uses': {'type': 'string'},
            },
          },
        ],
        'discriminator': {
          'propertyName': 'type',
          'mapping': {'run': '#/oneOf/0', 'uses': '#/oneOf/1'},
        },
      };

      final generator = SchemaGenerator(
        options: const SchemaGeneratorOptions(),
      );
      final generated = generator.generate(unionSchema);

      const expected = '''// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by json_schema2dart

sealed class Step {
  const Step();

  factory Step.fromJson(Map<String, dynamic> json) {
    final discriminator = json['type'];
    if (discriminator is String) {
      switch (discriminator) {
        case 'run':
          return Run.fromJson(json);
        case 'uses':
          return Uses.fromJson(json);
      }
    }
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final constMatches = <Step Function(Map<String, dynamic>)>[];
    final constMatchNames = <String>[];
    if (json['type'] == 'run') {
      constMatches.add(Run.fromJson);
      constMatchNames.add('Run');
    }
    if (json['type'] == 'uses') {
      constMatches.add(Uses.fromJson);
      constMatchNames.add('Uses');
    }
    if (constMatches.length == 1) {
      return constMatches.single(json);
    }
    if (constMatches.length > 1) {
      throw ArgumentError('Ambiguous Step variant matched const heuristics: \${constMatchNames.join(', ')}');
    }
    final requiredMatches = <Step Function(Map<String, dynamic>)>[];
    final requiredMatchNames = <String>[];
    if (keys.contains('type') && keys.contains('run')) {
      requiredMatches.add(Run.fromJson);
      requiredMatchNames.add('Run');
    }
    if (keys.contains('type') && keys.contains('uses')) {
      requiredMatches.add(Uses.fromJson);
      requiredMatchNames.add('Uses');
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError('Ambiguous Step variant matched required-property heuristics: \${requiredMatchNames.join(', ')}');
    }
    throw ArgumentError('No Step variant matched heuristics (keys: \${sortedKeys.join(', ')}).');
  }

  Map<String, dynamic> toJson();
}

class Run extends Step {
  final String run;
  final String type;

  const Run({
    required this.run,
    required this.type,
  }) : super();

  factory Run.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final run = json['run'] as String;
    remaining.remove('run');
    final type = json['type'] as String;
    remaining.remove('type');
    return Run(
      run: run,
      type: type,
    );
  }

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['run'] = run;
    map['type'] = type;
    map['type'] = 'run';
    return map;
  }
}

class Uses extends Step {
  final String type;
  final String uses;

  const Uses({
    required this.type,
    required this.uses,
  }) : super();

  factory Uses.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final type = json['type'] as String;
    remaining.remove('type');
    final uses = json['uses'] as String;
    remaining.remove('uses');
    return Uses(
      type: type,
      uses: uses,
    );
  }

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['type'] = type;
    map['uses'] = uses;
    map['type'] = 'uses';
    return map;
  }
}
''';

      expect(generated, expected);
    });
  });
}
